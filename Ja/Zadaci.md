
Primena priority_queue  (DS)    \
https://codeforces.com/contest/1185/problem/C2

Jako dobar zadatak, moras praviti malo ozblinjije obzervacije gledaj na malim testovima patern (Tree + DS)   \
https://codeforces.com/problemset/problem/1528/C

Ako primetimo walk ce najvise biti 2logn (DS)    \
https://codeforces.com/contest/914/problem/D 

ImpicitLazySegtree ili kompresija kverija (obratiti paznju na kverije sa l = r)  (DS)   \
https://codeforces.com/contest/803/problem/G

Zadatak iz kombinatorike (ako ti je resenje 2 ^ (n - 1) * (m - 1) ne smes da radis 2^mul(n - 1, m - 1), nego moras (2 ^ (n - 1)) ^ (m - 1)) (Math)         
https://codeforces.com/contest/894/problem/B

Nesto mi je cudan (Constructive + Math)    \
https://codeforces.com/contest/894/problem/C

Malo je cudan skontati, al je jako dobar zadatak (Greedy)  \
https://codeforces.com/contest/1554/problem/B

Mo gde treba naci broj dobrih segmenata (DS)   \
https://codeforces.com/problemset/problem/877/F

Nisam gledao da moram da skinem logn faktor i kad radis light-light probaj i preko elemenenata dobra fora (SQRT)   \
https://codeforces.com/problemset/problem/1468/M

Nisam obration paznju da ima multiple ivica izmedju dva cvora pa ne moze da idem kroz sve cycle-ove (Graph)   \
https://atcoder.jp/contests/abc191/tasks/abc191_e

Nisam znao brute force da uradim, gledati matricu nekad i kao nis (ravnu)              \
https://atcoder.jp/contests/abc196/tasks/abc196_d

Kad treba koliko ima brojeva a + b <= X, gledaj odvojeno a + b = X i a + b < X mozda pomogne (DP)    \
https://atcoder.jp/contests/abc129/tasks/abc129_e        \
https://atcoder.jp/contests/abc154/tasks/abc154_e

Extended gcd proveriti jos jednom sad sam preumoran (Math)    \
https://atcoder.jp/contests/abc186/tasks/abc186_e

Primetise koji svi kandidati mogu biti i onda samo radimo greedy da dobijem minimalno operacija ako je taj kandidat gcd      \
https://atcoder.jp/contests/abc136/tasks/abc136_e

Negative weighted cycle    \
https://atcoder.jp/contests/abc137/tasks/abc137_e

Classic   \
https://atcoder.jp/contests/abc173/tasks/abc173_e

Veoma lep constranctiv zadatak, malo cudan za constrainins al ok     \
https://codeforces.com/contest/892/problem/D

Veoma dobra ideja, gledati kako se vrednosti redom menjaju i updejtovati ih po tome    \
https://codeforces.com/group/EO1Eu2qKmY/contest/370830/problem/B 

Prevedi u matematicki recnik pa ce dobiti neki uslovi      \
https://www.codechef.com/problems/MAGICMOD

Mnogo lud zadatak        \
https://www.codechef.com/LTIME105A/problems/COOKPERM

Mo on tree    \
https://codeforces.com/contest/375/problem/D

Inclusion-Exclusion    \
http://usaco.org/index.php?page=viewproblem2&cpid=862

Trebalo je da se uvidi da se resenje moze dobiti i sortiranjem pa koriscenjem tog nekog subarray    \
https://oj.uz/problem/view/IOI16_molecules

Treba zadnji subtask da se gleda odvojeno     \
https://oj.uz/problem/view/APIO15_sculpture

Treba videti kako smanjiti broj edge-ova koje pravim i koja je slozenost kroz slucajeve moze vec od sqrt(N)    \
https://oj.uz/problem/view/APIO15_skyscraper

Primeti se da je lakse ako imamo razliku svaku dva susedna jer onda ne moram da updejtujemo ceo interval nego samo granice    \
https://oj.uz/problem/view/JOI17_foehn_phenomena

Posmatram zadatak kao graph i to dodavanje gledam kao bipartitivni od x i y koridate i samo pomnozim    \
https://atcoder.jp/contests/abc131/tasks/abc131_f

Slican kao onaj sa Usaca sa inclusion-exlusion, samo gledam svaki row koliko dodaje pa gledam je l ima da se ponavljaju i tako dalje sa inclusion-exlusion       
     https://atcoder.jp/contests/abc246/tasks/abc246_f
     
Uoci se da ako neki edge ne pripada bilo kom shortst path-u mozemo da ga brisemo, to znaci da je nama dovoljno da pogledamo samo susedni da li ima neki put 
manji od njega ili da li postoji duzi put sa istom distancom                         
https://atcoder.jp/contests/abc243/tasks/abc243_e

Fora sa average i medainom, kao i malo cudnija fora sa binarom kad koristim double i bez mog ans      \ 
https://atcoder.jp/contests/abc236/tasks/abc236_e

Sortiarati i raditi greedy od najmanje do najvece, najlepsi zadatak          \
https://atcoder.jp/contests/abc236/editorial/3306         \
https://atcoder.jp/contests/abc236/tasks/abc236_f

Samo se gleda ako i-ti cvor obojimo jednom od 2 boje, a boju cvora 0 fiksiramo. I posto za svaki cvor imamo 3 edga samo gledamo da imaju razlicite boje i 
samo treba voditi racuna o 1 i n              \
https://atcoder.jp/contests/abc229/tasks/abc229_f

Moze da gledamo prosirei graph gde postoji edge izmedju u -> u' sa tezionom D[u] i onda za neki cvor ce najveca distanca biti ili pocetak ili kraj diametra     \
https://atcoder.jp/contests/abc222/tasks/abc222_f

Treba primeti da koliko svaka RAZLICITA subsequence dodaje resenju i samim tip se lako dolazi do resenje ako fiksiranmo granice    \ 
https://atcoder.jp/contests/abc159/tasks/abc159_f

Primetimo koliko dobrinosi neka maska-a, ali ne cuvamo broj neko resenje odmah            \
https://atcoder.jp/contests/abc169/tasks/abc169_f

3^n nece proci, ali posto znam da prvom cvoru stavljam jednu boju i ondo samo 2^(n - 1) nacina ostaje za sledece sto prolazi        \
https://atcoder.jp/contests/abc199/tasks/abc199_d

Samo gledam ako dodam poslednji na kraj u skup da li i dalje vaze uslovi (dp + bitmask)     \
https://atcoder.jp/contests/abc199/tasks/abc199_e

Samo prosirujem palindrom koji na pocetku ili bude nista (samo cvor) ili 1 karakter (samo ivica) i onda dodajem levo i desno isti karatker    \
https://atcoder.jp/contests/abc197/tasks/abc197_f

Treba videti da nam je najbolje sto pre da stignem u svaki cvor je l mozemo u njemu da budemo koliko hocemo, i onda samo naci min funkcije preko 
izvoda i gledamo malo levo i desno cisto zbog int-a        \
https://atcoder.jp/contests/abc204/tasks/abc204_e

Rapise se i ide se na to koliko puta koristimo operaciju puta 2 (recimo C puta), i onda treba minimizirati |k1| + |k2| + |k3| + .... + |kc|, gde je to
A = 2^C * k1 + 2^(C - 1) * k2 + .... + kC, i to radimo znaci svaki ili oduzmemo ili dodamo ako ima taj bit i onda gledamo minimalno (vidi se u kodu)  \
https://atcoder.jp/contests/abc188/tasks/abc188_f

Kad imamo dva sortirana niza A (rastuce), B (opadajuce) i vazi |A| = |B|, pozicije gde su A[i] = B[i] formiranju segmente (nije tesko dokazati), to je 
bila glavna observacija za zadatak      \
https://atcoder.jp/contests/abc178/tasks/abc178_f

Samo treba uvideti da ako ako fiksiramo broj elemenata K, resenje je ako ima suma neka da je X % K = Suma % K, i samo treba da nadjemo max Suma da vazi 
dato    \
https://atcoder.jp/contests/abc192/tasks/abc192_f

Treba naci koliko ima nizova P tako da nema vazi P[i] != i, to se radi sa PIE, neka A[j] bude broj nizova tako da ima barem j pozicija gde je P[j] = j,
A[0] - A[1] + A[2] - A[3] + ... . Bilo mi je cudno da ako imam A[1] sto ne mogu da samo da oduzmem od ukupnog, ali ja nemam tacnu formulu za A[1], posto je A[j] = bin(N, j) * bin(M - j, N - j) * (N - j)!, to (N - j)! tu se moze desiti svasta i mogu se ponavljati zbog toga moram da radim PIE     \
https://atcoder.jp/contests/abc172/tasks/abc172_e

Primetimo da ako idemo da najmanjem dodamo, a najvecem oduzmemo desice se slucaj 1, 1, 0 gde treba da gledamo i sledeci par pa na osnovu toga da dodajemo      \
https://atcoder.jp/contests/abc166/tasks/abc166_f

Primetimo da svaki string moze biti ((((((, ))))))) , ))))(((( ili prazan kada sklonimo sve dobre parove zagrada. Treba gledati kao sta nemoze pokvariti resenje i tako praviti string, to znaci da tamo gde je broj '(' veci od ')', idem po rastuce po broju ')', a inace idem rastuce po broju '(' od pozadi. Nekako je najprirodnije da ovako pravimo resenje         \
https://atcoder.jp/contests/abc167/tasks/abc167_f

Opet PIE, msm po constrains se vidi da retko sta moze, treba da okrenemo zadatke 2^(n - 1) - Broj_losih_bojenja(L), to L se izracunava kao i zadatak NEQ, 
neka P[i] bude broj nacina da ne vazi bar i uslova      \
https://atcoder.jp/contests/abc152/tasks/abc152_f

Znaci ovde se koristi prefix sum i vazi f(x,y) = f(x - 1,0) + f(x - 1,1) + ... f(x - 1, y) kao i f(x, y) = bin(x + y, y), i sa tip treba da izracunamo 
Sum(i, 0, n) Sum(j, 0, m) bin(i + j, j) => Sum(i, 0, n) bin(i + m + 1, m) preko https://en.wikipedia.org/wiki/Hockey-stick_identity        \
https://atcoder.jp/contests/abc154/tasks/abc154_f

Isti je kao onaj sa 2019, samo sto ne radi kad je P = 2, ili P = 5, odnosno ne radi za one brojeve koji zavise od poslendnje cifre     \
https://atcoder.jp/contests/abc158/tasks/abc158_e

Znaci kad je resenje malo cak i kad nam se cini da brute force ne bi prosao, moze cak i proci posto malo casova valja      \
https://atcoder.jp/contests/abc211/tasks/abc211_e

Samo se gleda ako je svako povecanje >= X, koliko ih ima i onda samo nadjemo resenje. Malo smara kad je daje manje od M onda samo gledam ans - 1, i oduzmes ans - 1 onoliko puta koliko je tu otislo preko M    \
https://atcoder.jp/contests/abc149/tasks/abc149_e

Vidimo da ce nam finalni string biti duzine N = |S| + K, postoji 26^N stringova i nama treba oni koji sadrze S kao subsequece. Lakse je da izbrojimo koliko ima onih koji ne sadrze S kao subsequnce. Ako nemamo S[1] u stringu: 25^N nacina, ako imamo S[1] a nemamo S[2]: N * 25^(N - 1) ... itd znaci uzmemo i fiksiramo prefix i samo gledamo da nemam sledeci i onda mozemo da stavimo sta god hocemo      \
https://atcoder.jp/contests/abc171/tasks/abc171_f

Prvo sam mislio da moze da se resi tako da dp[i][j][l] bude broj nacina u prvih i ako je duzina sekvence j i ako je najmanji koriscen l, ali ispostavi se da malo teze idu tranzicije. Posto ako mi uzmemo i-ti ja moram da imam i sve manje od Q[i], i samim tip mozemo da gledamo dp[i][j][l] - broj nacina u prvih i ako je duzina sekvence j i ako je najmanji element koji NISMO koristili l. I sad kad smo na i-tom mozemo da ga ne koristimo ili koristimo.
Kad ga koristimo gledamo broj nacina da nismo koristili neki koji je veci od X, jer ako je manji onda moramo da ga koristimo. I ako necemo da koristimo X,
onda samo gledamo koji nam je najmanji koji nismo koristili      \
https://atcoder.jp/contests/abc238/tasks/abc238_f

Neka g(i,j) bude min(lcp[i + 1], ... ,lcp[j]), sad za svako i treba da izracunamo g(1,i) + g(2, i) + .. g(i - 1,i) + g(i,i + 1) + .... g(i, n). Neka B[i] = g(1, i) + ... g(i - 1,i), primetimo vezu imedju B[i] i B[i + 1], da treba samo svaku proslo da uproedim sa lcp[i + 1], i cuvamo {koji_je,koliko_se_pojavljuje} posto ce biti rastuce uvek u tom setu gde drzimo mozem stack in bude O(n) posto svaki ubacim jednom i izbacim jednom   \
https://atcoder.jp/contests/abc213/tasks/abc213_f

Prvo sam pomislio da moze dp[i][j] - max u prvih i ako nisam koristio j, pa da onda nekako vezujem sa i-tim i radim nesto. Neke cemo da stavljamo levo neke desno. Pi - kranjnja pozicija i-tog. Za indeske koje stavljam levo vazi Ai * (i - pi), kako nam Ai * i = const. bitno nam je samo da minimizujemo sumu Ai * pi, sto radimo sto najveci stavljamo skroz levo itd. Za indekse koje stavljam desno vazi Ai * (pi - i), opet Ai * i = const. bitno nam je samo da maximinujemo Ai * pi, sto radimo tako sto najveci stavljamo skroz desno itd. I sad gledamo DP[i][j] - max ako i stavljam levo i j desno    \
https://atcoder.jp/contests/abc163/tasks/abc163_e

Treba da nadjemo broj permutacija tako da je lcm cycle-ova jednak j. To radimo preko dp[i][j] - broj permutacija u prvih i tako da je lcm = j. Sad samo moramo za izbegnemo ponavljanje sto je malo teze i nije mi jasno. Treba da se fiksira najmanji koji nismo koristili i onda samo da pogledam na ostatku koliko njih mogu da izaberem     \
https://atcoder.jp/contests/abc226/tasks/abc226_f

Posto nam nisu bitni ostali elementi osim X, bitno nam je samo koji su veci od X i koji su manji pa mozemo niz da prbacimu 0 - niz[i] < X, 1 - niz[i] = X,
2 - niz[i] > X, i onda samo sort ako onaj zadatak sa stringovima na CF     \
https://atcoder.jp/contests/abc237/tasks/abc237_g

Ja kazem najmanji mi je X, to znaci da sve vece od X moram uzeti, tako da cu gledati da prodjem kroz tacno K tih polja i trazim najmanju sumu    \
https://atcoder.jp/contests/abc227/tasks/abc227_f

Broj delioca mozemo preko formule, a za to nam trebaju broj svakog prostog faktora. bin(N, K) = N * (N - 1) * ... * (N - K + 1) / K * (K - 1) ... * 1. 
Za svaki prosto faktor dodam koliko se puta nalazi u brojiocu i oduzmemo koliko se puta nalazi imeniocu. Za imenioc je lako posto je K <= 10^6. Za brojilac svaki prosto faktor ce biti manji od korena tog broja sem onaj deo sto ostane, kako N <= 10^12 sqrt(N) <= 10^6 mozemo isto kao i za imenioc samo moramo da dodamo onaj prost broj sto ostane       \
https://atcoder.jp/contests/abc227/tasks/abc227_g

Ja sam ovaj zadatak uspeo da resim sa phi nisam nisugran sto to radi, ova njihova ideja sa primitnivnim root-om je jako i dobro i moze se cesto korisiti. Definicija primitvnog root-a kao i resenje zadatka https://atcoder.jp/contests/abc212/editorial/2373.       \
https://atcoder.jp/contests/abc212/tasks/abc212_g

Ideja je veoma cudna ali je Geothermal objasnio motivaciju kod ovakih problma :
     My motivation: the difficult part of this problem is clearly performing range Fibonacci updates, so our first order of business is to simplify          the queries. One common way of simplifying range queries is to transform the array in order to turn range queries into point queries (consider,        for example, the standard trick of storing the difference array instead of the original array in order to handle range updates/point queries            using a BIT or standard segtree). When we perform standard range additions, the change in xn−xn−1 is zero for points in the middle of the array;        in this case, we see that for points in the middle of the update, the change in xn−xn−1−xn−2 is zero. Therefore, after performing the given            transformation, the range updates influence only a few points of the array, which is what we hoped to achieve.     
     https://codeforces.com/contest/1634/problem/F
     
Primetimo da nesto se puno pominje paran broj i samim tip pomislimo na Euler Cycle (odmah se vidi da je u pitanju nekakav graph, odnostno biparitite grpah kad ga konsrutisemo)       \
https://codeforces.com/contest/1634/problem/E

Nisam bas morao da gledam da li se svi manji od X pojavljuju mogao sam da li ima nekog koga nema. I to je onda lako, samo cuvam poslednej pojaljivanje  \
https://codeforces.com/problemset/problem/1436/E

Bitno nam je kako da proverimo da li je resenje X, odnosno gledamo kada je resenje < X, bitni su nam samo oni vec od X i njih hocemo da izbrisemo, sto znaci da najdesniji >= X mora imati desno od njega barem jednu bombu, drugi sa desna >= X mora imati dve bombe, itd. I onda samo gledamo za svako i ako hocemo da resenje bude < X, razliku  broj vecih >= X desno od i - broj bombi desno od i -> to mozemo lako sa segmentnim.    \
https://codeforces.com/contest/1326/problem/E

Primetimo prvo za fiksirano k da mozemo greedy da izracunamo resenje, tako sto od kraja samo uzimamo segment sve dok broj razlicitih ne predje k (sto je lako uvedeti). Za svako to k mozemo da izracunamo u ans(k) * log(n), ukupna slozenost ce nam biti suma svih k-ova, a ans(k) <= n / k, 
log(n) * (ans(1) + ans(2) + ... ans(n)) <= log(n) * (n / 1 + n / 2 + ... n / n) = log(n) * n * log(n), sto je veoma brzo. Drugo resenje nam je da radimo D&C. Primetimo da nam resenje opada pa mozemo kao negu D&C Dp optimization. Koliko puta cemo to naivno da izvrsimo? za k od 1...N mi imamo sqrt(N) razlicitih resenja, posto funcija f(x) = [N / x] ima sqrt(4N) + 1 razlicitih resenje i sam tim cemo naivno da izvrsimo za svako razliticito resenje       \
https://codeforces.com/contest/786/problem/C

Lako se vidi resenje O(nmk), ne moze drugacije, sem contanst optimization. Koristicemo bitset. Primetimo da mozemo da cuvamo n bitset-ova duzine m i sad radimo za svako slovo odvojeno. Za 'N' samo cemo ovo iz desno dodati na levo, 'S' samo cemo ovo iz levo dodati na desno. 'W' i 'E' nisam znao, ali mozemo samo shift posto je to samo pomeranje redo levo i desno. Moramo samo svaki taj novi red da pogledamo da nismo stali na kopno samo uradimo and sa I[i] gde je I[i][j] - 1 ako imam voda i 0 ako je kompno. Resimo zadatak O(nmk * 1/64)       \
https://oj.uz/problem/view/BOI19_nautilus

Treba primetiti da je dovoljno naci broj dobrih resenja za svaki bit odvojeno. Fiskiramo bit i radimo dp[i] - broj nacina u prvih i ako je poslednja 0 u i, i svi segmenti do sada su dobri. Nas onda samo interesuju segmenti koju celim delom bili pre i (r < i), jer kod njih ova nula nece uticati pa nemozemo da radimo bas sta hocemo. Znaci potrebno je da nadjemo max l za koje je r < i, i u opsegu [max l, i - 1] bude barem jedna 0, tako da je dp[i] = dp[i - 1] + ... + dp[mx[i]], ovim cemo pokriti slucaj sta ako stavimo predhodu nulu u segmentu [r + 1, i - 1], posto je dp[i] definisan da vazi sa sve segmente pre njega vec tako da smo to pokrili.         \
https://codeforces.com/contest/1327/problem/F

Vidimo da je nemoguce da swapujem ove dve matrice i pogledam da li mogu nekako da smanjim bitna polja, to ce biti samo one na obimu. Posto mogu da cuvam samo poziciju desnog cvora i poziciju donjeg cvora svakog polja, onda ove unutra se ne menjanju samo ovi na obimu. I onda samo njima moram da menjam desnu i donju poziciju. (E sad ne znam kako da vratim vrednosti na pocetak).       \
https://codeforces.com/problemset/problem/706/E

Gledamo granu sa najvecom tezinom to znaci da bilo koji put izmedju cvorova "LEVO" i "DESNO" ce sadrzati ovu granu, i onda izbrisemo tu granu i gledamo "LEVU" komponentu i "DESNU" komponetnu itd. Sam tim cemo kontrusati binarno stablo i svakoj toj grani cemo dodati cvor i njega cemo vezivati sa LEVOM-om i DESNO-om komponentom (a covorovi u grapu ce biti leaf-ovi u binarnom stablu). I onda za max tezinu izmedju dva cvora je samo LCA da dva cvora u binarnom stablu. I onda samo klasicno lazu segment sa updateove.      \
https://codeforces.com/contest/1628/problem/E

Kada nam da treba odgovor i iz [l, r] da vazi Li >= l dodaj Vi, a i imamo update. To bi mogli tako sto bi za svako i dodali na svako persistento od [i, n] vrednost Vi na poziciju Li, ali to je presporo. Tako da mozemo da vidimo da je to kao prefix sum, tako da mozemo da koristmo fenwick-a i samo one peristente u update u fenwcik dodajemo ovu vrednost      \
https://codeforces.com/problemset/problem/848/C

Dobro nam je kad nam je prava u obliku Ax + By = C, onda ako su date 2 tacke (x1, y1) i (x2, y2), za A, B i C sledi A = y2-y1, B = x1-x2, C = Ax1+By1
https://dmoj.ca/problem/coci06c2p6

Dobijao sam TLE(posto je mnogo cvorova imao trie), a kod trie je bitno da od pocetka do tr budu svi isti i primetimo da su mi isti (i, Ai) (j, Aj) na k-tom bitu kada je xor za k-ti bit jednak izmedju dva para, tako da mozemo da smanjimo trie samo na xor = 0 i xor = 1. Ako hocemo da da k-ti bude veci, samo cuvamo kombinaciju za (j, Aj), tako za (i, Ai) bude vece i samo cuvamo maximalu u svakom cvoru -> mx[tr][i][j]          \
https://codeforces.com/contest/1720/problem/D2

Hashovanje skupa proslo je kada sam koristio 2 prosta stepen1    \
https://codeforces.com/contest/1794/problem/E

Pokusavamo nekako da ogranicimo diametar, ako gledamo od nekog cvora v, max distancu = mx, meni vazi: dia <= 2 * mx (Neka je dia = dist(a, b) ako je dia > 2 * mx, a ja znam da postoji put izmedju a i b gde je dist(a, b) <= 2 * mx i onda imamo manje rastojanje, a kako je dist(a, b) = dia minimalno rastonjanje izmedju njjih to je kontradikcija) i vazi onda dia / 2 <= mx <= 2 * dia. Meni se dia smanjuje sto idem dalje u kverije, mx >= dia / 2 uvek vazi, a mx necu vise moci da korstim ako je 2 * dia < mx sledi da mogu da korstim mx / 2 i tako da dalje radim sve dok ne dodjem do zadnjeg kverij   \
https://codeforces.com/problemset/problem/1804/F

Prvo gledamo brute force resenje sa cuvanjem ivica i to nase resnje je O(nsqrt(n)log(n)) sto je presporo. Hocemo nekako da se resimo log(n) faktora to radimo tako sto gledamo koliko svaki nivo ima cvorova, ako gledamo svaki i-ti nivo i oni imaju cnt[i] < sqrt(n), mi to mozemo da cuvamo u nizu samo svaki par (x,y) imacemo ukupno nsqrt(n). Ako gledam svaki i-ti nivo i oni imaju cnt[i] >= sqrt(n), kroz njih mozemo samo da prodjem poshto njih ima max nsqrt(n)    \
https://codeforces.com/contest/1806/problem/E

Kada primetimo svojstvo funkcije F, gledamo sa kojim x da ga oduzmemo svaki put, ako ga oduzmemo sa minimumom nama je onda niz oblika 0, A1, A2, ... An
iz cega slede da nam je max clan F([0,A1,A2.,,,,An]) <= An iz cega sledi da ce nam uvek vrednosti biti <= 10^9      \
https://codeforces.com/contest/1805/problem/F1


