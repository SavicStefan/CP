
Primena priority_queue  (DS)    \
https://codeforces.com/contest/1185/problem/C2

Jako dobar zadatak, moras praviti malo ozblinjije obzervacije gledaj na malim testovima patern (Tree + DS)   \
https://codeforces.com/problemset/problem/1528/C

Ako primetimo walk ce najvise biti 2logn (DS)    \
https://codeforces.com/contest/914/problem/D 

ImpicitLazySegtree ili kompresija kverija (obratiti paznju na kverije sa l = r)  (DS)   \
https://codeforces.com/contest/803/problem/G

Zadatak iz kombinatorike (ako ti je resenje 2 ^ (n - 1) * (m - 1) ne smes da radis 2^mul(n - 1, m - 1), nego moras (2 ^ (n - 1)) ^ (m - 1)) (Math)         
https://codeforces.com/contest/894/problem/B

Nesto mi je cudan (Constructive + Math)    \
https://codeforces.com/contest/894/problem/C

Malo je cudan skontati, al je jako dobar zadatak (Greedy)  \
https://codeforces.com/contest/1554/problem/B

Mo gde treba naci broj dobrih segmenata (DS)   \
https://codeforces.com/problemset/problem/877/F

Nisam gledao da moram da skinem logn faktor i kad radis light-light probaj i preko elemenenata dobra fora (SQRT)   \
https://codeforces.com/problemset/problem/1468/M

Nisam obration paznju da ima multiple ivica izmedju dva cvora pa ne moze da idem kroz sve cycle-ove (Graph)   \
https://atcoder.jp/contests/abc191/tasks/abc191_e

Nisam znao brute force da uradim, gledati matricu nekad i kao nis (ravnu)              \
https://atcoder.jp/contests/abc196/tasks/abc196_d

Kad treba koliko ima brojeva a + b <= X, gledaj odvojeno a + b = X i a + b < X mozda pomogne (DP)    \
https://atcoder.jp/contests/abc129/tasks/abc129_e        \
https://atcoder.jp/contests/abc154/tasks/abc154_e

Extended gcd proveriti jos jednom sad sam preumoran (Math)    \
https://atcoder.jp/contests/abc186/tasks/abc186_e

Primetise koji svi kandidati mogu biti i onda samo radimo greedy da dobijem minimalno operacija ako je taj kandidat gcd      \
https://atcoder.jp/contests/abc136/tasks/abc136_e

Negative weighted cycle    \
https://atcoder.jp/contests/abc137/tasks/abc137_e

Classic   \
https://atcoder.jp/contests/abc173/tasks/abc173_e

Veoma lep constranctiv zadatak, malo cudan za constrainins al ok     \
https://codeforces.com/contest/892/problem/D

Veoma dobra ideja, gledati kako se vrednosti redom menjaju i updejtovati ih po tome    \
https://codeforces.com/group/EO1Eu2qKmY/contest/370830/problem/B 

Prevedi u matematicki recnik pa ce dobiti neki uslovi      \
https://www.codechef.com/problems/MAGICMOD

Mnogo lud zadatak        \
https://www.codechef.com/LTIME105A/problems/COOKPERM

Mo on tree    \
https://codeforces.com/contest/375/problem/D

Inclusion-Exclusion    \
http://usaco.org/index.php?page=viewproblem2&cpid=862

Trebalo je da se uvidi da se resenje moze dobiti i sortiranjem pa koriscenjem tog nekog subarray    \
https://oj.uz/problem/view/IOI16_molecules

Treba zadnji subtask da se gleda odvojeno     \
https://oj.uz/problem/view/APIO15_sculpture

Treba videti kako smanjiti broj edge-ova koje pravim i koja je slozenost kroz slucajeve moze vec od sqrt(N)    \
https://oj.uz/problem/view/APIO15_skyscraper

Primeti se da je lakse ako imamo razliku svaku dva susedna jer onda ne moram da updejtujemo ceo interval nego samo granice    \
https://oj.uz/problem/view/JOI17_foehn_phenomena

Posmatram zadatak kao graph i to dodavanje gledam kao bipartitivni od x i y koridate i samo pomnozim    \
https://atcoder.jp/contests/abc131/tasks/abc131_f

Slican kao onaj sa Usaca sa inclusion-exlusion, samo gledam svaki row koliko dodaje pa gledam je l ima da se ponavljaju i tako dalje sa inclusion-exlusion       
     https://atcoder.jp/contests/abc246/tasks/abc246_f
     
Uoci se da ako neki edge ne pripada bilo kom shortst path-u mozemo da ga brisemo, to znaci da je nama dovoljno da pogledamo samo susedni da li ima neki put 
manji od njega ili da li postoji duzi put sa istom distancom                         
https://atcoder.jp/contests/abc243/tasks/abc243_e

Fora sa average i medainom, kao i malo cudnija fora sa binarom kad koristim double i bez mog ans      \ 
https://atcoder.jp/contests/abc236/tasks/abc236_e

Sortiarati i raditi greedy od najmanje do najvece, najlepsi zadatak          \
https://atcoder.jp/contests/abc236/editorial/3306         \
https://atcoder.jp/contests/abc236/tasks/abc236_f

Samo se gleda ako i-ti cvor obojimo jednom od 2 boje, a boju cvora 0 fiksiramo. I posto za svaki cvor imamo 3 edga samo gledamo da imaju razlicite boje i 
samo treba voditi racuna o 1 i n              \
https://atcoder.jp/contests/abc229/tasks/abc229_f

Moze da gledamo prosirei graph gde postoji edge izmedju u -> u' sa tezionom D[u] i onda za neki cvor ce najveca distanca biti ili pocetak ili kraj diametra     \
https://atcoder.jp/contests/abc222/tasks/abc222_f

Treba primeti da koliko svaka RAZLICITA subsequence dodaje resenju i samim tip se lako dolazi do resenje ako fiksiranmo granice    \ 
https://atcoder.jp/contests/abc159/tasks/abc159_f

Primetimo koliko dobrinosi neka maska-a, ali ne cuvamo broj neko resenje odmah            \
https://atcoder.jp/contests/abc169/tasks/abc169_f

3^n nece proci, ali posto znam da prvom cvoru stavljam jednu boju i ondo samo 2^(n - 1) nacina ostaje za sledece sto prolazi        \
https://atcoder.jp/contests/abc199/tasks/abc199_d

Samo gledam ako dodam poslednji na kraj u skup da li i dalje vaze uslovi (dp + bitmask)     \
https://atcoder.jp/contests/abc199/tasks/abc199_e

Samo prosirujem palindrom koji na pocetku ili bude nista (samo cvor) ili 1 karakter (samo ivica) i onda dodajem levo i desno isti karatker    \
https://atcoder.jp/contests/abc197/tasks/abc197_f

Treba videti da nam je najbolje sto pre da stignem u svaki cvor je l mozemo u njemu da budemo koliko hocemo, i onda samo naci min funkcije preko 
izvoda i gledamo malo levo i desno cisto zbog int-a        \
https://atcoder.jp/contests/abc204/tasks/abc204_e

Rapise se i ide se na to koliko puta koristimo operaciju puta 2 (recimo C puta), i onda treba minimizirati |k1| + |k2| + |k3| + .... + |kc|, gde je to
A = 2^C * k1 + 2^(C - 1) * k2 + .... + kC, i to radimo znaci svaki ili oduzmemo ili dodamo ako ima taj bit i onda gledamo minimalno (vidi se u kodu)  \
https://atcoder.jp/contests/abc188/tasks/abc188_f

Kad imamo dva sortirana niza A (rastuce), B (opadajuce) i vazi |A| = |B|, pozicije gde su A[i] = B[i] formiranju segmente (nije tesko dokazati), to je 
bila glavna observacija za zadatak      \
https://atcoder.jp/contests/abc178/tasks/abc178_f

Samo treba uvideti da ako ako fiksiramo broj elemenata K, resenje je ako ima suma neka da je X % K = Suma % K, i samo treba da nadjemo max Suma da vazi 
dato    \
https://atcoder.jp/contests/abc192/tasks/abc192_f

Treba naci koliko ima nizova P tako da nema vazi P[i] != i, to se radi sa PIE, neka A[j] bude broj nizova tako da ima barem j pozicija gde je P[j] = j,
A[0] - A[1] + A[2] - A[3] + ... . Bilo mi je cudno da ako imam A[1] sto ne mogu da samo da oduzmem od ukupnog, ali ja nemam tacnu formulu za A[1], posto je A[j] = bin(N, j) * bin(M - j, N - j) * (N - j)!, to (N - j)! tu se moze desiti svasta i mogu se ponavljati zbog toga moram da radim PIE     \
https://atcoder.jp/contests/abc172/tasks/abc172_e

